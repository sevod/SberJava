#2. Типы данных
* None type - тип, представляющий отсутствие значения.
* None - неопределенное значение переменной.
* Логический тип данных (bool) 
* int - целое число
* float - число с плавающей точкой
* complex - комплексное число
* str - строка
* list - список
* tuple - кортеж это список, который после создания нельзя изменить
* range - Генератор списков используется, когда нам нужно вывести последовательность целых чисел. диапазон, неизменяемая последовательность целых чисел.
* set - множество. коллекции для неповторяющихся данных, хранящие эти данные в случайном порядке.
* frozenset - неизменяемое множество
* dict - словарь являются набором пар "ключ"-"значение"
* bytes - байты
* bytearray - массивы байт

`type(типданных)`

#3. Типы операторов

#####Операторы членства
* in
* not in

#####Операторы тождественности
* is
* in not

#4. Условные операторы
````
var_1 = 10
var_2 = -10
if var_1 == var_2:
    print("var_1 equal var_2")
elif var_1 < var_2:
    print("var_1 less than var_2")
else:
    print("var_1 more than var_2")
````

`var = input('Введите данные\n')` ввод данных с консоли

#5. Циклы

````
var = 1
while var <= 13:
    print(var)
    var += 1
````
````
for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]:
    print(i)
````
````
for i in range(1, 14):
    print(i)
````

`continue` позволяет начать следующий проход цикла, минуя оставшиеся инструкции

`break` досрочно прерывает цикл

`else` Блок инструкций внутри else выполнится только в том случае, если выход из цикла произошел без помощи break.

#8. Строки
https://partner.sberbank-school.ru/programs/11907/item/460643

` \ ` символ экранировки.

`\n` - перевод строки

`print('spam' * 3)` дублирование строки (выведет 3 spam в одну строку строки)

`len('Python')` длина

`print(s[5])` обращение по индексу

###Срез
````
>>> s = 'Python'
>>> print(s[1:2])
y
>>> print(s[0:])
Python
>>> print(s[:3])
Pyt
>>> print(s[:])
Python
````

`find(str, [start],[end])` - Поиск подстроки в строке. Возвращает номер первого вхождения или -1

`index(str, [start],[end])` - Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError

`rindex(str, [start],[end])` - Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError

`replace(шаблон, замена)` - Замена по шаблону

`split(символ)` - Разбиение строки по разделителю, возвращает массив

`isdigit()` - Состоит ли строка из цифр

`isalpha()` - Состоит ли строка из букв

`isalnum()` - Состоит ли строка из цифр или букв

`islower()` - Состоит ли строка из символов в нижнем регистре

`isupper()` - Состоит ли строка из символов в верхнем регистре

`istitle()` - Начинаются ли слова в строке с заглавной буквы

`upper()` - Преобразование строки к верхнему регистру

`lower()` - Преобразование строки к нижнему регистру

`startswith(str)` - Начинается ли строка S с шаблона str

`endswith(str)` - Заканчивается ли строка S шаблоном str

`join(список)` - Сборка строки из списка с разделителем S


#9. Списки
https://partner.sberbank-school.ru/programs/11907/item/460646

Для создания списка автоматически можно использовать метод `list()`
````
>>> list('Python')
['P','y','t','h','o','n']
````
````
# Пустой список
>>> s = []
# список с данными разных типов
>>> l = ['s', 'p', ['isok'], 2]
````

Генераторы списков
````
>>> a = ['P', 'y', 't', 'h', 'o', 'n']
>>> b = [i * 3 for i in a]
````

`a[1]` обращение через индекс

`len(a)` - количество элементов в списке

`append(a)` - добавляет элемент a в конец списка

`extend(L)` - расширяет список, добавляя к концу все элементы списка L

`insert(i, a)` - вставляет на i позицию элемент a

`remove(a)` - удаляет первое найденное значение элемента в списке со значением a, возвращает ошибку, если такого элемента не существует

`pop(i)` - удаляет i-ый элемент и возвращает его, если индекс не указан, удаляет последний элемент

`index(a)` - возвращает индекс элемента a (индексация начинается с 0)

`count(a)` - возвращает количество элементов со значением a

`sort([key = функция])` - сортирует список на основе функции, можно не прописывать функцию, тогда сортировка будет происходить по встроенному алгоритму

`reverse()` - разворачивает список

`copy()` - поверхностная копия списка, при присвоении переменной копии списка, 
значение данного списка не изменяется в случае изменения первого. 
Если переменной присвоить список через "=", 
тогда значение этой переменной будет меняться при изменении оригинала

`clear()` - очищает список

#10. Кортежи
https://partner.sberbank-school.ru/programs/11907/item/460649
кортежи это неизменяемые списки.

`a = (1, 2, 3, 4, 5, 6)`

`a = 1, 2, 3, 4`

`a = tuple()` создание пустого кортежа

#11. Словари
https://partner.sberbank-school.ru/programs/11907/item/460650

`d = {'a': 1, 'b': 2}`

`d = dict(short='dict', long='dictionary')`

````
>>> d = dict([(1, 1), (2, 4)])
>>> print(d)
{1: 1, 2: 4}
````

`d = {'dict': 1, 'dictionary': 2}`

Еще один способ создать словарь - использовать метод fromkeys():
````
>>> d = dict.fromkeys(['a', 'b'])
>>> print(d)
{'a': None, 'b': None}
>>> d = dict.fromkeys(['a', 'b'], 100)
>>> print(d)
{'a': 100, 'b': 100}
````
Также можно использовать генератор словарей:
````
>>> d = {a: a ** 2 for a in range(7)}
>>> print(d)
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
````
`print(d[1])` - обращение по ключу (1)

###Методы для работы со словарями

`clear()` - очищает словарь

`copy()` - возвращает копию словаря

`fromkeys(seq[,value])` - создает словарь с ключами из seq и значением value
````
>>> d.fromkeys(['a', 'b'], 10)
{'a' : 10, 'b' : 10}
````

`get(key[, default])` - возвращает значение ключа, но если его нет, возвращает default

`items()` - возвращает пары (ключ, значение)

`keys()` - возвращает ключи в словаре

`pop(key[, default])` - удаляет ключ и возвращает значение. Если ключа нет, возвращает default

`popitem()` - удаляет и возвращает пару (ключ, значение) с конца

`setdefault(key[, default])` - возвращает значение ключа, но если его нет, создает ключ с значением default

`update([other])` - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются

`values()` - возвращает значения в словаре

#12. Множества
https://partner.sberbank-school.ru/programs/11907/item/460653

множества содержат неповторяющиеся данные в произвольном порядке.

`a = {'a', 'b', 'c', 'd'}`

````
>>> a = set('hello')
>>> print(a)
{'h', 'o', 'l', 'e'}
````

###Методы для работы со множествами
`len(s)` - число элементов в множестве (размер множества)

`x in s` - принадлежит ли x множеству s

`isdisjoint(other)` - истина, если set и other не имеют общих элементов

`issubset(other)` или set <= other - истина, если все элементы set принадлежат other

`issuperset(other)` или set >= other - аналогично

`union(other, ...)` или set | other | ... - возвращает объединение нескольких множеств

`intersection(other, ...)` или set & other & ... - возвращает пересечение множеств

`difference(other, ...)` или set - other - ... -возвращает множество из всех элементов set, не принадлежащие ни одному из other

`symmetric_difference(other)`; set ^ other - возвращает множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих

`copy() `- копия множества

`update(other, ...)`; set |= other | ... - объединение множеств.

`intersection_update(other, ...)`; set &= other & ... - пересечение множеств. 

`difference_update(other, ...)`; set -= other | ... - вычитание множеств. 

`symmetric_difference_update(other)`; set ^= other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.

`add(elem)` - добавляет элемент в множество. 

`remove(elem)` - удаляет элемент из множества. KeyError, если такого элемента не существует.

`discard(elem)` - удаляет элемент, если он находится в множестве.

`pop()` - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.

`clear()` - очистка множества.

#13. Функции
https://partner.sberbank-school.ru/programs/11907/item/460656
````
def sum(x, y):
    return x + y
````
* Глобальные функции - такие функции доступны из любой части кода файла
* Локальные функции - функции, объявленные внутри других функций.
* Лямбда-функции - особые, анонимные функции, имеющие ряд ограничений, по сравнению с обычными функциями.
````
# Обычная функция 
def search_len(arg_1):
    return len(arg_1) 
# Лямбда-функция 
result = lambda x: len(x)
````

* Методы - функции, работающие в связке с тем типом данных, который ассоциирован с данной функцией. 

Произвольное количество аргументов. (*args) на входе кортеж
````
>>> def func(*args):
      return args
>>> func(1, 2, 3, 'abc')
(1, 2, 3, 'abc')
````
На вхоже словарь (**kwargs)
````
>>> def func(**kwargs):
        return kwargs
>>> func(a=1, b=2, c=3)
{'a': 1, 'c': 3, 'b': 2}
````
Документирование функции с помощью тройных ковычек
````
def solve(s):
    ''' Функция solve(s) принимает список 
        создает пустой список   
        находит элементы с четным индексом (включая 0) 
        заносит их в созданный список и возвращает его 
    '''
    c = []
    for i in range(len(s)-1):
        if i == 0 or i%2 == 0:
            c.append(s[i])
    return c
````

Проверка входящего значения

`assert type(s) == list`

#14. Исключения
https://partner.sberbank-school.ru/programs/11907/item/460793
````
Существует множество видов исключений, вот только некоторые из них:

BaseException - базовое исключение, порождающее все остальные
SystemExit - системное исключение, порождаемое функцией sys.exit при выходе из программы
KeyboardInterrupt - системное исключение, порождаемое пользовательским выходом из программы с помощью сочетания клавиш 
ArithmeticError - арифметическая ошибка
AssertionError - выражение assert ложно
ImportError - ошибка импорта модуля или его атрибута
IndexError - индекс не входит в диапазон элементов
NameError - не найдено переменных с таким именем
SyntaxError - ошибка синтаксиса
TypeError - операция к объекту несоответствующего типа
и т.д.
````

###Конструкция try...except
````
try:
    try_suite
except exception_group1 as variable1:
    except_suite1
...
except exception_groupN as variableN: 
    except_suiteN
else:
    else_suite
finally:
    finally_suite
````
 `finally`  выполняется всегда и в последнюю очередь.

#15. Работа с файлами
https://partner.sberbank-school.ru/programs/11907/item/460794

`f = open('test.txt', 'r')`

````
'r' - открытие на чтение(значение по умолчанию)
'w' - открытие на запись, содержимое файла удаляется и перезаписывается заново, если файла не существует, создается новый
'x' - открытие на запись, только если файла не существует
'a' - открытие на дозапись, информация добавляется в конец файла
'b' - открытие файла в двоичном виде
't' - открытие в текстовом режиме(значение по умолчанию)
'+' - открытие на чтение и запись
````
 `read()`
````
>>> f = open('test.txt')
>>> f.read()
'Python is\nAwesome!.\n\n'
````
````
>>> f = open('test.txt') 
>>> for line in f:
    print(line)
'Python is\n'
'\n'
'Awesome\n'
'\n'
````
`close()` По окончании работы с файлом его необходимо закрыть

#16. Подключение модулей
https://partner.sberbank-school.ru/programs/11907/item/460796

`import`

Модулем в Python называется любой файл с программой с расширением .py
````
>>> import datetime
>>> print(datetime.datetime.today()) 
2019-08-13 12:34:49.444292
````

````
>>> import datetime as m
>>> print(m.datetime.today())
2019-08-13 12:34:49.444292
````
````
>>> from datetime import datetime as m
>>> print(m.today())
2019-08-13 12:34:49.444292
````

#17. Регулярные выражения.
https://partner.sberbank-school.ru/programs/11907/item/460814

`import re`

`re.match(шаблон, строка)` - ищет заданный шаблон с самого начала строки.

`re.search(шаблон, строка)` - ищет заданный шаблон по всей строке, возвращает результат при первом совпадении.

`re.findall(шаблон, строка)` - ищет заданный шаблон и возвращает все совпадения в виде списка.

`re.split(шаблон, строка)` - разделяет строку по заданному шаблону

`re.sub(шаблон, замена, строка)` - находит шаблон в строке и производит замену

`re.compile(шаблон)` - позволяет собирать регулярное выражение в отдельный объект для последующего использования

`специальные символы:` 

````
.	Один любой символ, кроме символа переноса строки \n	
>>> print(re.findall(r'h..', 'hey Hey Hey Hey'))
hey

?	0 или 1 вхождение шаблона слева	
>>> print(re.findall(r'h?', 'hey Hey Hey Hey'))
['h', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']

+	1 и более вхождений шаблона слева	
>>> print(re.findall(r'H.+', 'hey Hey Hey Hey'))
['Hey Hey Hey']
>>> print(re.findall(r'H+', 'hey Hey Hey Hey'))
['H', 'H', 'H']

*	0 или более вхождений слева	
>>> print(re.findall(r'H*', 'hey Hey Hey Hey'))
['', '', '', '', 'H', '', '', '', 'H', '', '', '', 'H', '', '', '']
\w	Любая цифра или буква (\W — все, кроме буквы или цифры)	
>>> print(re.findall(r'\w', 'hey Hey Hey Hey'))
['h', 'e', 'y', 'H', 'e', 'y', 'H', 'e', 'y', 'H', 'e', 'y']

\d	Любая цифра [0-9] (\D — все, кроме цифры)	
>>> print(re.findall(r'\d', 'hey Hey1 Hey2 Hey3'))
['1', '2', '3']

\s	Любой пробельный символ (\S — любой непробельный символ)	
>>> print(re.findall(r'\s', 'hey Hey1 Hey2 Hey3'))
[' ', ' ', ' ']

\b	Граница слова	
>>> print(re.findall(r'\b\w', 'hey, Hey1, Hey2, Hey3'))
['h', 'H', 'H', 'H']

[..]	Один из символов в скобках ([^..] — любой символ, кроме тех, что в скобках)	
>>> print(re.findall(r'[Hy]', 'hey, Hey1, Hey2, Hey3'))
['y', 'H', 'y', 'H', 'y', 'H', 'y']

\	Экранирование специальных символов (\. означает точку или \+ — знак «плюс»)	
>>> print(re.findall(r'\.', 'hey. Hey1. Hey2. Hey3'))
['.', '.', '.']

^ и $	Начало и конец строки соответственно	
>>> print(re.findall(r'..$', 'hey. Hey1. Hey2. Hey3'))
['y3']

{n,m}	От n до m вхождений ({,m} — от 0 до m)	
>>> print(re.findall(r'\w{2}', 'hey. Hey1. Hey2. Hey3'))
['he', 'He', 'y1', 'He', 'y2', 'He', 'y3']

a|b	Соответствует a или b	
>>> print(re.findall(r'h|3', 'hey. Hey1. Hey2. Hey3'))
['h', '3']

()	Группирует выражение и возвращает найденный текст	
>>> print(re.findall(r'(\w\w\w)', 'hey. Hey1. Hey2. Hey3\n'))
['hey', 'Hey', 'Hey', 'Hey']

\t,\n,\r	Символ табуляции, новой строки и возврата каретки соответственно	
>>> print(re.findall(r'\n', 'hey. Hey1. Hey2. Hey3\n'))
['\n']
````

#Дополнительные материалы
https://partner.sberbank-school.ru/programs/11907/item/460859


1. Документация Python
Справочник по языку Python:

https://docs.python.org/3/reference/index.html

Стандартная библиотека Python:

https://docs.python.org/3/library/index.html

Список документации Python:

https://docs.python.org/3/

2. Самоучитель Python

https://pythonworld.ru/samouchitel-python

3. Несколько популярных форумов, посвященных Python и программированию вообще
python-forum.io

https://www.dreamincode.net/forums/forum/29-python/

StackOverflow.com

4. Поддержка Jupyter Notebook предоставляется на следующих ресурсах
Jupyter-чат в реальном времени:

https://gitter.im/jupyter/jupyter

GitHub

https://github.com/jupyter/help

StackOverflow:

https://stackoverflow.com/questions/tagged/jupyter